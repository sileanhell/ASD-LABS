// https://github.com/AntonC9018/uniCourse_dataStructuresAndAlgorithms/blob/master/ru/labs/lab3.md

#include <stdlib.h>
#include <iostream>

int* stackMemory1()
{
    int a = 1; // Создаем локальную переменную 'a' и присваиваем ей значение 1.
    return &a; // Возвращаем указатель на 'a', что является проблемой, так как 'a' выходит из области видимости при завершении функции.
}

int* stackMemory2()
{
    int b = 2; // Создаем локальную переменную 'b' и присваиваем ей значение 2.
    return &b; // Возвращаем указатель на 'b', также приводящий к неопределенному поведению.
}

int main()
{
    int* b = stackMemory1(); // Вызываем функцию stackMemory1 и сохраняем возвращенный указатель в 'b'.
    int a1 = *b; // Раскрываем указатель 'b' и сохраняем значение в 'a1'.
    int* c = stackMemory2(); // Вызываем функцию stackMemory2 и сохраняем возвращенный указатель в 'c'.
    int a2 = *c; // Раскрываем указатель 'c' и сохраняем значение в 'a2'.
    int a3 = *b; // Попытка раскрыть указатель 'b' снова, что может привести к неопределенному поведению.

    std::cout << a1 << std::endl; // Выводим значение 'a1' на стандартный вывод.
    std::cout << a2 << std::endl; // Выводим значение 'a2' на стандартный вывод.
    std::cout << a3 << std::endl; // Выводим значение 'a3' на стандартный вывод.

    // Следующая строка пытается вычислить разницу между указателями 'b' и 'c'.
    // Это может привести к неопределенному поведению, так как 'b' и 'c' указывают на локальные переменные,
    // которые больше не существуют после завершения функций stackMemory1 и stackMemory2.
    std::cout << ((std::byte*) b - (std::byte*) c) << std::endl;

    return 0;
}
